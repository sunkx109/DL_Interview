# C++面试考点总结



## 1.关键字汇总

##### 1.1 static

作用

1. 修饰**普通变量**，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰**普通函数**，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，**修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员**。
4. 修饰成员函数，**修饰成员函数使得不需要生成对象就可以访问该函数**，但是**在 static 函数内不能访问非静态成员**。****

```C++
class mycls{
private:
    int data;
    static int nums; //静态变量不能在类中初始化

public:
    mycls(int data_)
    {
        data = data_;
    }
    void print()
    {
        std::cout<<"data:"<<data<<std::endl;
        num++;
        std::cout<<"static nums:"<<nums<<std::endl;
        
    }
    static void process()
    {
        nums++;
        std::cout<<"After static function process nums:"<<nums<<std::endl;
    }
};
//静态变量需要先在类外部进行初始化，才能被类的成员函数访问
//静态成员变量或静态成员函数 在外部进行定义的时候不能带static
int mycls::nums=0;
int main()
{
    mycls tmp = mycls(7);
    tmp.print();
}
```



##### 1.2 const



##### 1.3 extern



##### 1.4 volatile



##### 1.5 decltype

auto和decltype关键字都可以自动推导出变量的类型，但是他们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value; //exp 表示一个表达式
```

auto根据'='右边的初始值value推导出变量的类型，而decltype根据exp表达式推导出变量的类型，跟"="右边的value没有关系。另外，auto要求变量必须初始化，而decltype不要求。这很容易理解，auto是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导。

## 2. C++11

#### 2.2  C++中四种类型转换

C++中四种类型转换分别为**const_cast、static_cast、dynamic_cast、reinterpret_cast**,四种转换功能如下：

1. const_cast ： **将const变量转为非const**

2. static_cast：**最常用**，**可以用于各种隐式转换，比如非const转const**，static_cast可以用于类向上转换，但向下转换能成功但不安全

3. dynamic_cast : **只能用于含有虚函数的类转换，用于类向上和向下转换**

   向上转换：子类向基类转换

   向下转换：基类向子类转换

   这两种转换，子类包含父类，当父类转换为子类时可能出现非法内存访问的问题。dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI(RunTime Type Information)技术提供了运行时确定对象类型的方法。

4. reinterpret_cast：**几乎什么都可以转**，比如将int转指针，可能会出问题，尽量少用；

 

#### 2.3 智能指针

四个智能指针：auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

**智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。**所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. auto_ptr

   auto_ptr指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错，已被C++11 弃用

2. unique_ptr

   unique_ptr规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错

   > 实现原理：将拷贝构造函数和赋值拷贝构造函数声明为private或delete。不允许拷贝和赋值操作，但是支持移动构造函数，通过move把一个对象指针变成右值之后可以移动给另一个unique_ptr

3. shared_ptr

   shared_ptr可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。

   > 实现原理：有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数+1 ，当引用计数为0时，释放资源
   >
   > https://cloud.tencent.com/developer/article/1688444

4. weak_ptr : 是用来解决shared_ptr相互引用导致死锁的智能指针

**线程安全性**

多线程读写shared_ptr所指的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，都需要加锁保护



#### 2.4 右值引用和move语义



#### 2.5 Lambda匿名函数



## 3. 面向对象

#### 3.1 构造函数汇总



#### 3.2 继承

三种继承方式：

| 继承方式      | 基类的public成员  | 基类的protected成员 | 基类的private成员 |
| ------------- | ----------------- | ------------------- | ----------------- |
| pubilc继承    | 仍为public成员    | 仍为protected成员   | 不可见            |
| protected继承 | 变为protected成员 | 仍为protected成员   | 不可见            |
| private继承   | 变为private成员   | 变为private成员     | 不可见            |

1. 子类对象可以赋值给父类对象(切片)；父类对象不可以赋值给子类对象
2. 父类指针或者引用可以指向子类对象；子类的指针或者引用不可以指向父类对象

总结：父(->/=) 子（可以） ，子(->/=)父(不行)；基类引用(指针)可以 = 子类对象 ，反之则不行，

#### 6. C++的重载和重写

1. 重写：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型都必须要同基类中被重写的函数一致。只有**函数体**不同，**派生类对象调用时会调用派生类的重写函数，不会调用被重写函数**。且重写的基类中被重写的函数必须有virtual修饰
2. 重载：函数名相同，但**参数列表不同**，函数体实现也不同

* 在基类的函数前加上vitual关键字叫做虚函数，虚函数肯定是类的成员函数；

* 存在虚函数的类都有一个一维的虚函数表叫做虚表，类对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针式和对象对应的

  > https://zhuanlan.zhihu.com/p/75172640

* 纯虚函数是虚函数再加上=0 ，抽象类是指包括至少一个纯虚函数的类，抽象类必须在子类实现这个函数，抽象类不能示例化。



#### 7. C++中的多态

静态多态：函数重载

动态多态：虚函数



#### 8. 说说为什么要虚析构，为什么不能虚构造

1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构

   * 用派生类类型指针绑定派生类实例，析构时，不管基类析构是不是虚函数，都会正常析构
   * **用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。**为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只能一句指针的类型来进行，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

   C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。对于不会被继承的类来说，其析构函数如果是虚函数就会浪费内存

2. 不能虚构造：

   * 从存储空间角度：虚函数对应一个vtable，这个表**的地址是存储在对象的内存空间的。**如果将构造函数设置为虚函数，就需要到vtable中调用，可是对象还没有实例化，没有分配内存空间，如何调用？
   * 虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

   

#### 9. 虚函数和纯虚函数 实现原理

1. C++中的虚函数的作用主要是实现了多态机制。关于多态，简而言之就是**用父类型的指针指向其子类的实例**，然后**通过父类的指针调用实际子类的成员函数**。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果**调用非虚函数**，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据**调用该函数的对象，引用或指针的类型**而确定。如果调用虚函数，则**直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。**
2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方式。



#### 10. C++中哪些函数不能被声明为虚函数

常见的不能声明为虚函数的有：普通函数(非成员函数)、静态成员函数、内联成员函数、构造函数、友元函数。

1. 为什么不支持内联成员函数为虚函数？

   inline在函数编译时被展开，虚函数在运行时才能动态绑定

2. 为什么不支持静态成员函数为虚函数？（待定）

   静态成员函数对每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别

3. 为什么不支持友元函数为虚函数？

   因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。







#### 11.深拷贝与浅拷贝

1. 浅拷贝：将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象公用一份实体，**只是所引用的变量名不同，地址其实还是相同的**。

2. 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向不同的内存位置。

3. 深拷贝的实现：深拷贝的**拷贝构造函数**和**赋值运算符**的重载传统实现：

   ```c++
   //对于复制构造函数就是重新开辟一块空间
   STRING(const STRING& s)
   {
      //_str = s._str
      _str = new char[strlen(s._str)+1];
      strcpy_s(_str,strlen(s._str)+1,s._str);
   }
   
   STRING& operator=(const STRING& s)
   {
       if(this!=&s)
       {
          delete[] _str;
          this->_str = new char[strlen(s._str)+1];
          strcpy_s(this->_str,strlen(s._str)+1,s._str);
       }
       return *this;
   }
   ```

   





